#include <minimum_spanning_tree.h>

using namespace std;

namespace Graph
{
    //==========================================================================
    //--------------------------------------------------------------------------
    MinimumSpanningTree::MinimumSpanningTree(int v) :
        _vertices        (v),
        _edges           (0),
        _adjList         (v, new edge_container_t())
    {}

    //--------------------------------------------------------------------------
    MinimumSpanningTree::~MinimumSpanningTree()
    {
        for_each(_adjList.begin(), _adjList.end(), delete_element<edge_container_t *>());
    }

    //--------------------------------------------------------------------------
    //NOTE : Vertex index is NOT bound checked
    //--------------------------------------------------------------------------
    void MinimumSpanningTree::addEdge(const Edge &e)
    { 
        int v = e.either(), w = e.other(v);
        
        _adjList[v]->insert(e);
        _adjList[w]->insert(e);

        ++_edges;
    }

    //--------------------------------------------------------------------------
    const MinimumSpanningTree::edge_container_t & MinimumSpanningTree::adjacent(int v) const
    { 
        return *_adjList[v];
    }

    //--------------------------------------------------------------------------
    int MinimumSpanningTree::vertices() const
    { 
        return _vertices;        
    }

    //--------------------------------------------------------------------------
    int MinimumSpanningTree::edges() const
    { 
        return _edges;
    }

    //--------------------------------------------------------------------------
    void MinimumSpanningTree::edges(edge_container_t &rEdges)
    { 
        //for_each(_adjList.begin(), _adjList.end());
        
        for(int v = 0; v < _vertices; ++v)
        {
            //for_each(_adjList[v]->begin(), _adjList[v]->end(),
            //         inserter(rEdges, rEdges.begin()));

            for(edge_iterator it = _adjList[v]->begin(); it != _adjList[v]->end(); ++it)
                rEdges.insert(*it);
        }
        
    }

    //--------------------------------------------------------------------------
    std::string MinimumSpanningTree::toString()
    { 
        return "";
    }

}
